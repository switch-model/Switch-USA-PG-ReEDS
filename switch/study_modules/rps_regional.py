import os, math
from pyomo.environ import *

from switch_model.utilities import unique_list

"""

This module defines a regional Renewable Portfolio Standard (RPS) policy scheme
for the Switch model. In this scheme, each generator in each zone is categorized as RPS-
elegible or not.
Dispatched electricity that is generated by RPS-elegible sources in each
period and zone is summed up and must meet an energy goal in each zone, set as a required percentage
of all energy that is generated in that period. Distributed generation will be counted toward
the percentage if it is marked as eligible for the program; otherwise it will be used to reduce
load, which will partially reduce the amount of other renewables needed.

Distributed generation and VPP generators (interruptible loads)
(gen_is_distributed or gen_is_vpp) are subtracted from load before the RPS
calculation if not marked as RPS-eligible.

Storage units (m.gen_storage_efficiency != '.') will be excluded from the
renewable production total even if marked eligible, because they are not net
sources of power.

This module does not allow eligibility determination based on fuel used in
multi-fuel generators. See switch_model.hawaii.rps for an example of that.

# TODO:
# make transfers go from zone-eligibility group to requirements group
# where the requirements groups are all unique subsets of the eligibility group.
# Also define routes that will be congested by these flows, assuming transfers
# from each zone-eligibility group along the lowest-loss path to the requirements
# group. And for each requirement, have a list of routes that can serve it.
"""


def define_components(m: AbstractModel):
    """
    RPS_PROGRAM is a set of program/regions that have target shares of clean
    power (typically a renewable portfolio standard (RPS) or clean energy
    standard (CES)).

    RPS_GEN is a set of generators that are eligible for
    producing clean power (RPS-eligible).

    load_zone is a subset of model regions where RPS goals are defined.

    rps_share[z in load_zone] is the fraction of total generated energy in
    a period in a zone that has to be provided by RPS-elegible generators.
    """
    # indexing set for the zonal requirements: (program, period, zone) combination
    # (These are all the index columns from rps_requirements.csv.)
    m.RPS_RULES = Set(dimen=3, within=Any * m.LOAD_ZONES * m.PERIODS)

    # share target specified for each (program, period, zone) combination
    m.rps_share = Param(m.RPS_RULES, default=float("inf"), within=Reals)

    # fraction of required RECs in each program/period that can come from
    # unbundled trade
    m.unbundled_rec_limit_fraction = Param(
        m.RPS_RULES, within=PercentFraction, default=1
    )

    if not hasattr(m, "gen_is_vpp"):
        m.gen_is_vpp = Param(m.GENERATION_PROJECTS, within=Binary, default=0)
        m.gen_is_vpp.added_by = __name__

    # names of all the RPS programs and periods when they are in effect;
    # each unique pair of values in the first two columns of
    # RPS_requirements.csv is a (program, period) combo
    m.RPS_PROGRAM_PERIODS = Set(
        dimen=2,
        within=Any * m.PERIODS,
        initialize=lambda m: unique_list((pr, pe) for pr, z, pe in m.RPS_RULES),
    )

    # set of RPS programs
    m.RPS_PROGRAMS = Set(
        initialize=lambda m: unique_list(pr for pr, pe in m.RPS_PROGRAM_PERIODS)
    )

    # set of zones that participate in a particular RPS program in a particular period
    # TODO: build these more efficiently
    m.ZONES_IN_RPS_PROGRAM_PERIOD = Set(
        m.RPS_PROGRAM_PERIODS,
        within=m.LOAD_ZONES,
        initialize=lambda m, pr, pe: unique_list(
            _z for (_pr, _z, _pe) in m.RPS_RULES if (_pr, _pe) == (pr, pe)
        ),
    )
    m.ZONES_IN_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS,
        within=m.LOAD_ZONES,
        initialize=lambda m, pr: unique_list(
            _z for (_pr, _z, _pe) in m.RPS_RULES if _pr == pr
        ),
    )

    # set of all valid program/generator combinations (i.e., gens participating
    # in each program); we omit storage gens even if designated as allowed,
    # because they are not a net source of power (could relax this and add net
    # power instead?). Any eligible gens that are not in a home zone for the
    # RPS program will need to be imported on a bundled or unbundled basis.
    m.RPS_PROGRAM_GENS = Set(dimen=2, within=m.RPS_PROGRAMS * m.GENERATION_PROJECTS)
    # set of all RPS-eligible gens
    m.RPS_GENS = Set(within=m.GENERATION_PROJECTS)
    # gens in each program and programs for each gen
    m.GENS_IN_RPS_PROGRAM = Set(m.RPS_PROGRAMS, within=m.RPS_GENS)
    m.RPS_PROGRAMS_FOR_GEN = Set(m.RPS_GENS, within=m.RPS_PROGRAMS)

    @m.BuildAction()
    # populate the sets efficiently
    # (from https://pyomo.readthedocs.io/en/6.7.3/pyomo_modeling_components/Sets.html)
    def populate_rps_program_gens(m):
        for pr, g in m.RPS_PROGRAM_GENS:
            m.RPS_GENS.add(g)
            m.GENS_IN_RPS_PROGRAM[pr].add(g)
            m.RPS_PROGRAMS_FOR_GEN[g].add(pr)

    #############
    # Bundled REC (BREC) flows. These are cases where power is scheduled to flow into
    # an RPS's region from an RPS-eligible generator in a zone outside that
    # region. We pre-identify the lowest-loss routes and assume power will
    # always be scheduled to flow along those. Then we require that a matching
    # amount of power is dispatched along these lines. Note that this means
    # bundled RECs can't be applied to one program in one zone and a different
    # program in another zone.
    # Note: in the code below, "BREC-eligible gens" means gens that are
    # eligible to deliver bundled RECs to other zones for RPS programs there.

    # Flags indicating whether each gen is able to send bundled or unbundled
    # RECs to each program it participates in.
    # Note: send_unbundled_recs is mainly used to indicate which regions allow
    # REC trading with each other; send_bundled_recs is mainly used to manage
    # model size, since policy-wise bundled RECs are always allowed, at least in
    # the U.S. (under the dormant commerce clause), but tracking flows between
    # zones is computationally intensive, so it generally works best to only
    # send bundled RECs to neighboring states or major trading partners (if
    # multiple neighboring states have RPSs, state A could send bundled RECs to
    # state B, which then sends some of its own bundled RECs to state C,
    # modeling somewhat wider inter-zone trading). Note that if a gen is able to
    # send bundled RECs to a particular zone for one program, it can also send
    # it to the same zone for other programs, even if not permitted here (REC
    # transfer is treated as gen-to-zone, not gen-to-program).
    m.send_bundled_recs = Param(m.RPS_PROGRAM_GENS, within=Binary, default=False)
    m.send_unbundled_recs = Param(m.RPS_PROGRAM_GENS, within=Binary, default=True)
    # Flag identifying whether each gen can create RECs directly (locally) for
    # each RPS program it participates in
    m.create_local_recs = Param(
        m.RPS_PROGRAM_GENS,
        within=Binary,
        initialize=lambda m, pr, g: m.gen_load_zone[g] in m.ZONES_IN_RPS_PROGRAM[pr],
    )

    # all RECs must be eligible for local or export use, but not both
    m.recs_for_local_xor_export_use = m.BuildCheck(
        m.RPS_PROGRAM_GENS,
        rule=lambda m, pr, g: bool(m.create_local_recs[pr, g])
        ^ bool(m.send_bundled_recs[pr, g] or m.send_unbundled_recs[pr, g]),
    )

    # Eligibility groups are unique combinations of local program, remote
    # bundled and remote unbundled program that power can go to from each zone
    # (found by scanning and aggregating eligibility for all gens in the zone).
    # Requirement groups are unique combinations of programs that must be met in
    # some zone (found by scanning across and aggregting zones). EGs are sources
    # for RECs and RGs are potential destinations for RECs. BREC routes connect
    # each EG to all RGs that include any BREC-eligible program in that EG. UREC
    # routes connect each EG to any RGs that include any UREC-eligible program
    # in that EG. BREC flows are scheduled on each route an hourly basis. UREC
    # flows are scheduled on each UREC route per period. Anything left over each
    # period is considered a local REC.

    ################
    # Bundled REC trading

    # 1. find zone + eligibility groups from gens (and designate gens in each)
    # 2. find requirement groups
    # 2. find BREC routes (requirement groups with any member in each zone eligibility group)
    #    - need to change code below to only apply BREC/UREC routes that include each program
    #      in the eligibility group to that program (not enough to have a requirement group
    #      that includes the program)

    # IDs for eligibility groups; each of these represents a unique collection
    # of programs (and REC methods) that one or more generation projects are
    # eligible for
    m.ELIGIBILITY_GROUPS = Set(within=Any)

    # list of RPS_PROGRAMs in each eligibility group
    m.RPS_PROGRAMS_FOR_ELIGIBILITY_GROUP = Set(
        m.ELIGIBILITY_GROUPS, dimen=1, within=m.RPS_PROGRAMS
    )

    # valid combos of load zone and eligibility groups (for any gens in that zone)
    # (may or may not have REC trading allowed)
    m.ZONE_ELIGIBILITY_GROUPS = Set(within=m.LOAD_ZONES * m.ELIGIBILITY_GROUPS)

    # list of gens in zone z that are part of eligibility group eg
    # (each gen is in exactly one zone-eligibility group, so total RECs produced
    # for that group of programs = total production from all gens in the group)
    m.GENS_IN_ZONE_ELIGIBILITY_GROUP = Set(m.ZONE_ELIGIBILITY_GROUPS, within=m.RPS_GENS)

    # programs RECs can be sent to from each eligibility group
    m.BREC_PROGS_FOR_ELIGIBILITY_GROUP = Set(m.ELIGIBILITY_GROUPS)
    m.UREC_PROGS_FOR_ELIGIBILITY_GROUP = Set(m.ELIGIBILITY_GROUPS)
    m.LOCAL_PROGS_FOR_ELIGIBILITY_GROUP = Set(m.ELIGIBILITY_GROUPS)

    def progs_to_group(progs):
        """
        Turn a set of RPS programs into a unique group name. prog consists of
        either an RPS program or a tuple of (RPS program, send_bundled flag,
        send_unbundled flag)
        """
        if progs:
            if not isinstance(progs, list):
                progs = list(progs)
            # list of tuples of (program, local-eligible, bundled-eligible,
            # unbundled-eligible) (generally an eligibility group for some gen);
            # convert into text like "OH_RPS BREC / IN_RPS local / IL_CES UREC+BREC"
            if isinstance(progs[0], tuple):
                return " / ".join(
                    sorted(
                        pr
                        + " "
                        + "+".join(
                            (["local"] if l else [])
                            + (["BREC"] if b else [])
                            + (["UREC"] if u else [])
                        )
                        for pr, l, b, u in progs
                    )
                )
            elif isinstance(progs[0], str):
                # list of progs with no bundled/unbundled flags (generally a
                # requirements group in some zone): convert into text like
                # "OH_RPS / OH_CES"
                return " / ".join(sorted(pr for pr in progs))
        return ""  # default

    @m.BuildAction()
    def populate_eligibility_groups(m):
        # gather info on all REC programs that each gen is eligible for and
        # create a unique hash for that eligibility group (EG); use these to
        # build sets of unique EGs and cache information about where RECs from
        # this EG can be used
        for g in m.RPS_GENS:
            progs = [
                # tuples of (program, local-eligible flag, bundled-eligible flag, unbundled-eligible flag)
                (
                    pr,
                    bool(m.create_local_recs[pr, g]),
                    bool(m.send_bundled_recs[pr, g]),
                    bool(m.send_unbundled_recs[pr, g]),
                )
                for pr in m.RPS_PROGRAMS_FOR_GEN[g]
            ]
            eg_name = progs_to_group(progs)
            m.ELIGIBILITY_GROUPS.add(eg_name)
            m.ZONE_ELIGIBILITY_GROUPS.add((m.gen_load_zone[g], eg_name))
            m.GENS_IN_ZONE_ELIGIBILITY_GROUP[m.gen_load_zone[g], eg_name].add(g)
            for pr, l, b, u in progs:
                m.RPS_PROGRAMS_FOR_ELIGIBILITY_GROUP[eg_name].add(pr)
                if l:
                    m.LOCAL_PROGS_FOR_ELIGIBILITY_GROUP[eg_name].add(pr)
                if b:
                    m.BREC_PROGS_FOR_ELIGIBILITY_GROUP[eg_name].add(pr)
                if u:
                    m.UREC_PROGS_FOR_ELIGIBILITY_GROUP[eg_name].add(pr)

    # names of all requirements groups (sets of zone that have the same RPS
    # obligations); these are the destinations for BREC and UREC trade routes
    m.REQUIREMENTS_GROUPS = Set(dimen=1, within=Any)
    # Set of zones that are part of each requirements group (have the same RPS
    # requirements)
    m.ZONES_IN_REQUIREMENTS_GROUP = Set(m.REQUIREMENTS_GROUPS, within=m.LOAD_ZONES)
    # Set of requirements groups that each RPS program participates in (usually
    # just one); only used as intermediate set to build later ones
    m.RGS_FOR_RPS_PROGRAM = Set(m.RPS_PROGRAMS, within=m.REQUIREMENTS_GROUPS)

    # for each zone, find all requirements groups (requirements in effect in
    # some zone with some overlap with some member of an eligiblity group in
    # this zone) (TODO: update this comment)
    @m.BuildAction()
    def populate_requirements_groups(m):
        # Scan RPS zones to find all requirements groups (unique combinations of
        # RPS programs in effect in any zone) and make lists of matching RPS
        # programs for each requirements group
        zone_reqs = {}
        for pr in m.RPS_PROGRAMS:
            for z in m.ZONES_IN_RPS_PROGRAM[pr]:
                zone_reqs.setdefault(z, set()).add(pr)
        for z, progs in zone_reqs.items():
            rg = progs_to_group(progs)
            m.REQUIREMENTS_GROUPS.add(rg)
            m.ZONES_IN_REQUIREMENTS_GROUP[rg].add(z)
            for pr in progs:
                m.RGS_FOR_RPS_PROGRAM[pr].add(rg)

    # Set of BREC- or UREC-eligible routes from eligibility groups to matching
    # requirements groups. Per-timepoint BREC flows and per-period UREC flows
    # will be scheduled for each of these. For BRECs, a least-loss set of
    # transmission lines will also be pre-selected corresponding to this route,
    # and losses and congestion will be calculated along that path. Each route
    # is a tuple of (zone, eligibility group, requirements group). A
    # requirements group is considered to match an eligibility group if any
    # program in the requirements group is in the eligibility group. This way,
    # the model can choose to send RECs from zone A to any requirements group
    # (collection of zones with the same RPS programs) where they could be
    # useful.
    m.BREC_ROUTES = Set(
        dimen=3,
        # source zone, source eligibility group, destination requirements group
        within=m.LOAD_ZONES * m.ELIGIBILITY_GROUPS * m.REQUIREMENTS_GROUPS,
    )
    m.UREC_ROUTES = Set(
        dimen=3, within=m.LOAD_ZONES * m.ELIGIBILITY_GROUPS * m.REQUIREMENTS_GROUPS
    )

    # Set of all BREC and UREC routes that start from each zone - eligibility group combo
    m.BREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP = Set(
        m.ZONE_ELIGIBILITY_GROUPS, dimen=3, within=m.BREC_ROUTES
    )
    m.UREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP = Set(
        m.ZONE_ELIGIBILITY_GROUPS, dimen=3, within=m.UREC_ROUTES
    )

    # Set of BREC or UREC routes that serve each RPS program
    m.BREC_ROUTES_FOR_RPS_PROGRAM = Set(m.RPS_PROGRAMS, dimen=3, within=m.BREC_ROUTES)
    m.UREC_ROUTES_FOR_RPS_PROGRAM = Set(m.RPS_PROGRAMS, dimen=3, within=m.UREC_ROUTES)

    # Set of zone-eligibility group combos that are local to each RPS program, i.e.,
    # have generators in a zone governed by the program that can produce RECs for the program
    m.LOCAL_ZONE_ELIGIBILITY_GROUPS_FOR_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS, dimen=2, within=m.ZONE_ELIGIBILITY_GROUPS
    )

    @m.BuildAction()
    def populate_routes(m):
        # scan zone eligibility groups to get a list of all zone-eligibility
        # groups that can send URECs or BRECs to a requirements group. These
        # become routes for URECs or BRECs.
        for z, eg in m.ZONE_ELIGIBILITY_GROUPS:
            for pr in m.RPS_PROGRAMS_FOR_ELIGIBILITY_GROUP[eg]:
                # any requirement group that includes this program is a potential
                # destination for RECs from this eligibility group
                routes = [(z, eg, rg) for rg in m.RGS_FOR_RPS_PROGRAM[pr]]
                if pr in m.BREC_PROGS_FOR_ELIGIBILITY_GROUP[eg]:
                    m.BREC_ROUTES.update(routes)
                    m.BREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP[z, eg] = routes
                    m.BREC_ROUTES_FOR_RPS_PROGRAM[pr].update(routes)
                if pr in m.UREC_PROGS_FOR_ELIGIBILITY_GROUP[eg]:
                    m.UREC_ROUTES.update(routes)
                    m.UREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP[z, eg] = routes
                    m.UREC_ROUTES_FOR_RPS_PROGRAM[pr].update(routes)
                if pr in m.LOCAL_PROGS_FOR_ELIGIBILITY_GROUP[eg]:
                    m.LOCAL_ZONE_ELIGIBILITY_GROUPS_FOR_RPS_PROGRAM[pr].add((z, eg))

    ###########
    # BREC production during each timepoint

    # amount of BRECs to send from each EG to each eligible RG during each
    # timepoint
    m.ExportBRECsTP = Var(m.BREC_ROUTES, m.TIMEPOINTS, within=NonNegativeReals)

    # exports must be less than production for the corresponding eligibility
    # groups in the source zone
    @m.Constraint(m.ZONE_ELIGIBILITY_GROUPS, m.TIMEPOINTS)
    def BREC_Export_Below_Production(m, z, eg, tp):
        RTS = m.BREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP[z, eg]
        if RTS:
            brecs = sum(m.ExportBRECsTP[_z, _eg, _rg, tp] for _z, _eg, _rg in RTS)
            production = sum(
                m.DispatchGen[g, tp]
                for g in m.GENS_IN_ZONE_ELIGIBILITY_GROUP[z, eg]
                if (g, tp) in m.GEN_TPS
            )
            return brecs <= production
        else:
            return Constraint.Skip

    ###########
    # Find lowest-loss transmission path for each BREC route and require time-
    # matched flows (and losses) along these routes when BRECs are transferred

    m.ZONES_ON_BREC_ROUTE = Set(m.BREC_ROUTES, within=m.LOAD_ZONES, ordered=True)

    m.populate_zones_on_brec_routes = BuildAction(rule=populate_zones_on_brec_routes)

    # set of all zones along any BREC route (just used to index
    # brec_route_efficiency_to_zone)
    m.BREC_ROUTE_ZONES = Set(
        dimen=4,
        ordered=True,
        within=m.BREC_ROUTES * m.LOAD_ZONES,
        initialize=lambda m: [
            rte + (z,) for rte in m.BREC_ROUTES for z in m.ZONES_ON_BREC_ROUTE[rte]
        ],
    )

    # cumulative efficiency up to every zone on every route, including source
    # and destination
    def rule(m, z_source, eg, rg, z):
        if z == z_source:
            return 1
        # reuse efficiency up to previous zone (already calculated)
        prev_z = m.ZONES_ON_BREC_ROUTE[z_source, eg, rg].prev(z)

        return (
            m.brec_route_efficiency_to_zone[z_source, eg, rg, prev_z]
            * m.trans_efficiency[m.trans_d_line[prev_z, z]]
        )

    m.brec_route_efficiency_to_zone = Param(m.BREC_ROUTE_ZONES, rule=rule)

    # next two components are defined here, then populated below

    # indexed set of all BREC routes that use each transmission line
    m.BREC_ROUTES_USING_DIRECTIONAL_TX = Set(m.DIRECTIONAL_TX, within=m.BREC_ROUTES)

    @m.BuildAction()
    def populate_BREC_ROUTES_USING_DIRECTIONAL_TX(m):
        routes = {(zf, zt): [] for zf, zt in m.DIRECTIONAL_TX}
        for rte in m.BREC_ROUTES:
            # assign this BREC route to all the transmission lines along the way
            zones = iter(m.ZONES_ON_BREC_ROUTE[rte])
            prev_z = next(zones)  # first zone
            for next_z in zones:
                m.BREC_ROUTES_USING_DIRECTIONAL_TX[prev_z, next_z].add(rte)
                prev_z = next_z

    # transmission corridors that are affected by any BREC trade
    m.DIRECTIONAL_TX_ON_ANY_BREC_ROUTE = Set(
        within=m.DIRECTIONAL_TX,
        initialize=lambda m: [
            dtx for dtx, rte in m.BREC_ROUTES_USING_DIRECTIONAL_TX.items() if rte
        ],
    )

    # for every trans line, BREC trade along routes using that line must not
    # exceed actual power transfers along that line
    m.Require_BRECs_Below_TX_Transfers = Constraint(
        m.DIRECTIONAL_TX_ON_ANY_BREC_ROUTE,
        m.TIMEPOINTS,
        rule=lambda m, z_from, z_to, tp: sum(
            # bundled RECs reaching zone z_from along all z_start ->
            # z_dest routes that use this corridor, net of losses
            # prior to z_from
            m.ExportBRECsTP[rte + (tp,)]
            * m.brec_route_efficiency_to_zone[rte + (z_from,)]
            for rte in m.BREC_ROUTES_USING_DIRECTIONAL_TX[z_from, z_to]
        )
        <= (
            # power flow along this corridor
            m.DispatchTx[z_from, z_to, tp]
        ),
    )

    ##########
    # Total BREC trade per period for use in program-balancing below

    # amount of BRECs (MWh) exported from each EG to each RG during each period
    m.ExportBRECs = Expression(
        m.BREC_ROUTES,
        m.PERIODS,
        rule=lambda m, z, eg, rg, pe: sum(
            m.ExportBRECsTP[z, eg, rg, tp] * m.tp_weight[tp]
            for tp in m.TPS_IN_PERIOD[pe]
        ),
    )

    # amount of BRECs (MWh) reaching each program during each period, net of losses
    m.ImportBRECs = Expression(
        m.RPS_PROGRAM_PERIODS,
        rule=lambda m, pr, pe: sum(
            m.ExportBRECs[rte + (pe,)]
            * m.brec_route_efficiency_to_zone[
                rte + (m.ZONES_ON_BREC_ROUTE[rte].last(),)
            ]
            for rte in m.BREC_ROUTES_FOR_RPS_PROGRAM[pr]
        ),
    )

    ################
    # Unbundled REC (UREC) trading

    # This is similar to bundled REC (BREC) trading (RECs from specific gens are
    # designated as being exported to a particular zone where they are eligible
    # to participate in one or more RPS programs). However, we only tabulate
    # once per period instead of per timepoint, and we don't worry about the
    # transmission lines the power would flow on. Note that this disallows the
    # same REC from being used for different programs in different regions
    # (corresponding to requirements groups); we assume each REC moves to one
    # specific requirements group.

    # balance unbundled trades for every project every period: assign MWh from
    # that project to every allowed export jurisdiction, s.t., constraint that
    # allocations to all jurisdictions must be less than or equal to total
    # production minus bundled assignments

    # URECs go along UREC_ROUTES, which are valid combos of source zone +
    # eligibility group and dest requirements group, for zones outside the home
    # zone of the requirements (i.e., where m.gen_load_zone[g] not in
    # m.ZONES_IN_RPS_PROGRAM[pr] for g in m.GENS_IN_RPS_PROGRAM[pr])

    # amount of URECs to export from each UREC-export-eligible gen,
    # per destination zone, per period
    m.ExportURECs = Var(m.UREC_ROUTES, m.PERIODS, within=NonNegativeReals)

    # Create a decision variable for the total number of URECs to import into
    # each program during each period; it may be less than the number exported
    # to that eligibility group (in order to respect limits on use of URECs for
    # some programs), but must not exceed it. Note that the upper limit does not
    # consider transmission losses.
    m.ImportURECs = Var(m.RPS_PROGRAM_PERIODS, within=NonNegativeReals)

    # upper limit on URECs
    m.ImportURECs_below_ExportURECs = Constraint(
        m.RPS_PROGRAM_PERIODS,
        rule=lambda m, pr, pe: m.ImportURECs[pr, pe]
        <= sum(
            m.ExportURECs[z, eg, rg, pe]
            for z, eg, rg in m.UREC_ROUTES_FOR_RPS_PROGRAM[pr]
        ),
    )

    # local REC production for each eligibility group in each zone during each
    # period is the difference between total production and UREC + BREC production
    # (summed across eligibility groups that include this program)
    def rule(m, z, eg, pe):
        brec_export = sum(
            m.ExportBRECs[z, eg, rg, pe]
            for z, eg, rg in m.BREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP[z, eg]
        )
        urec_export = sum(
            m.ExportURECs[z, eg, rg, pe]
            for z, eg, rg in m.UREC_ROUTES_FOR_ZONE_ELIGIBILITY_GROUP[z, eg]
        )
        total_dispatch = sum(
            m.DispatchGen[g, tp] * m.tp_weight[tp]
            for g in m.GENS_IN_ZONE_ELIGIBILITY_GROUP[z, eg]
            if (g, pe) in m.GEN_PERIODS
            for tp in m.TPS_IN_PERIOD[pe]
        )
        return total_dispatch - brec_export - urec_export

    m.CreateLocalRECs = Expression(m.ZONE_ELIGIBILITY_GROUPS, m.PERIODS, rule=rule)

    # make sure local REC production is non-negative for each zone + eligibility
    # group, each period, i.e., UREC + BREC + local production does not exceed
    # total power production
    m.Require_Total_RECs_Below_Dispatch = Constraint(
        m.ZONE_ELIGIBILITY_GROUPS,
        m.PERIODS,
        rule=lambda m, z, eg, pe: m.CreateLocalRECs[z, eg, pe] >= 0,
    )

    # Total local RECs delivered to each program during each period
    m.ConsumeLocalRECs = Expression(
        m.RPS_PROGRAM_PERIODS,
        rule=lambda m, pr, pe: sum(
            m.CreateLocalRECs[z, eg, pe]
            for z, eg in m.LOCAL_ZONE_ELIGIBILITY_GROUPS_FOR_RPS_PROGRAM[pr]
        ),
    )

    ##############
    # Overall RPS rules and balancing

    # RPS target (MWh) in each zone for each program during each period. Any
    # production from local dist gen or vpp not eligible for the RPS will
    # instead be used to reduce sales of power below the gross level reported in
    # zone_total_demand_in_period_mwh. That in turn reduces the amount that
    # needs to be met under the RPS. (These will later get pooled across zones
    # to create the total target for the program. There's no real need to define
    # targets per zone, but it is more consistent with PowerGenome and avoids
    # the need to add a per-program-period input file.)
    def rule(m, pr, z, pe):
        # production by ineligible dist gen or VPPs
        non_rps_dg_vpp_output = sum(
            m.DispatchGen[g, tp] * m.tp_weight[tp]
            for g in m.GENS_IN_ZONE[z]
            if (
                (m.gen_is_distributed[g] or m.gen_is_vpp[g])
                and (pr, g) not in m.RPS_PROGRAM_GENS
            )
            for tp in m.TPS_FOR_GEN_IN_PERIOD[g, pe]
        )

        # rps share of net load in this zone for this program/period
        return m.rps_share[pr, z, pe] * (
            m.zone_total_demand_in_period_mwh[z, pe] - non_rps_dg_vpp_output
        )

    m.RPSZonalTargetMWh = Expression(m.RPS_RULES, rule=rule)

    # Total RPS target (MWh) for each program during each period.
    m.RPSProgramTargetMWh = Expression(
        m.RPS_PROGRAM_PERIODS,
        rule=lambda m, pr, pe: sum(
            m.RPSZonalTargetMWh[pr, z, pe]
            for z in m.ZONES_IN_RPS_PROGRAM_PERIOD[pr, pe]
        ),
    )

    # Enforce limit on URECs in each RPS program (has to build up from zonal
    # level because unbundled_rec_limit_fraction is specified per zone even
    # though the rule applies per program)
    m.URECs_Below_RPS_Program_Limit = Constraint(
        m.RPS_PROGRAM_PERIODS,
        rule=lambda m, pr, pe: m.ImportURECs[pr, pe]
        <= sum(
            m.unbundled_rec_limit_fraction[pr, z, pe] * m.RPSZonalTargetMWh[pr, z, pe]
            for z in m.ZONES_IN_RPS_PROGRAM_PERIOD[pr, pe]
        ),
    )

    # enforce overall RPS balance, including URECs, BRECs and local REC production
    # TODO: maybe multiply both sides by the scale factor below to convert
    # period-long multi-zone total energy into average energy per zone per hour
    # (matching the scale of the MW values used on the RHS for zonal energy
    # balances) (currently unused because it makes shadow value of RPS have
    # weird units and would introduce a small coefficient (the scale factor
    # itself) in the constraint matrix, which may not be helpful)
    # scale = 1.0 / (m.period_length_hours[pe] * len(m.ZONES_IN_RPS_PROGRAM_PERIOD[pr, pe]))
    m.Enforce_RPS_Share = Constraint(
        m.RPS_PROGRAM_PERIODS,
        rule=lambda m, pr, pe: m.ImportBRECs[pr, pe]
        + m.ImportURECs[pr, pe]
        + m.ConsumeLocalRECs[pr, pe]
        >= m.RPSProgramTargetMWh[pr, pe],
    )


def populate_zones_on_brec_routes(m):
    """
    Find the lowest-loss route from zone `z` to any zone in the requirements
    group `rg` for all (z, eg, rg) in m.BREC_ROUTES. Then use that to populate
    m.ZONES_ON_BREC_ROUTE[z, eg, rg]. This uses Dijkstra's method to find the
    routes from all zones in rg to all zones in eg at the same time, to improve
    efficiency.
    """
    # First, cluster routes with common rg, then for each rg, find the
    # paths to all the relevant zones, then use that to fill in
    # m.ZONES_ON_BREC_ROUTE[z, eg, rg] for all the relevant routes.
    # We could simplify this by creating EXTERNAL_ZONE_REQUIRMENT_GROUPS and
    # defining ZONES_ON_BREC_ROUTE over that instead of over all BREC_ROUTES,
    # but that might make the overall code a little harder to follow. So instead
    # we (1) find all zones that feed into each rg; (2) find the shortest path
    # (list of zone hops) from each of those zones to the rg; and (3) apply that
    # path to all BREC routes that use that zone and rg.

    # create a list of tuples of "costs" to move power from any zone to a
    # neighbor for the route-finder; this uses the negative log of efficiency so
    # that minimizing the sum of this "cost" across hops minimizes 1/(eff1 *
    # eff2 * ...), i.e., minimizes 1/efficiency, i.e., maximizes efficiency.
    edges = [
        (z1, z2, -math.log(eff))
        for z1, z2 in m.DIRECTIONAL_TX
        for eff in [m.trans_efficiency[m.trans_d_line[z1, z2]]]
        if eff > 0
    ]

    # find all zones that export BRECS to each rg
    source_zones_for_rg = {}
    for source_z, eg, rg in m.BREC_ROUTES:
        source_zones_for_rg.setdefault(rg, set()).add(source_z)

    # For each rg, find the shortest path from all zones that export to it
    routes_to_rg = {}
    for rg, source_zones in source_zones_for_rg.items():
        routes_to_rg[rg] = find_paths(
            from_zones=source_zones,
            to_zones=m.ZONES_IN_REQUIREMENTS_GROUP[rg],
            edges=edges,
        )

    # Apply assembled paths to all matching BREC routes
    for source_z, eg, rg in m.BREC_ROUTES:
        steps = routes_to_rg[rg][source_z]
        if steps is None:
            rg_zones = ", ".join(m.ZONES_IN_REQUIREMENTS_GROUP[rg])
            raise ValueError(
                f"No transmission route could be found from zone '{source_z}' "
                f"to requirements group '{rg}' ({rg_zones}). Either the "
                "transmission network is incomplete or generators in an "
                "unconnected zone have been marked eligible for bundled REC "
                "trade, which is not possible."
            )
        else:
            m.ZONES_ON_BREC_ROUTE[source_z, eg, rg] = steps


from typing import List, Tuple, Dict, Optional
import numpy as np
from scipy.sparse import csr_matrix
from scipy.sparse.csgraph import dijkstra


def find_paths(
    from_zones: List[str],
    to_zones: List[str],
    edges: List[Tuple[str, str, float]],
) -> Dict[str, List[str] | None]:
    """
    For each zone in `from_zones`, find the least-cost path to any zone in
    `to_zones` using non-negative directed edge costs. Returns a dict:
        { from_zone: List[str]|None }
    If a source cannot reach any destination, value will be None.
    """
    # TODO: improve documentation, maybe simplify code,

    # --- 1) Build node index map (strings -> ints)
    nodes = set()
    for u, v, _ in edges:
        nodes.add(u)
        nodes.add(v)
    nodes.update(from_zones)
    nodes.update(to_zones)
    nodes = sorted(nodes)
    n = len(nodes)
    index = {z: i for i, z in enumerate(nodes)}

    # --- 2) Build sparse adjacency (forward) and transpose (reversed)
    rows = np.fromiter((index[u] for u, _, _ in edges), dtype=int, count=len(edges))
    cols = np.fromiter((index[v] for _, v, _ in edges), dtype=int, count=len(edges))
    data = np.fromiter((float(w) for _, _, w in edges), dtype=float, count=len(edges))
    A = csr_matrix((data, (rows, cols)), shape=(n, n))

    AT = A.T  # reversed graph

    # --- 3) Multi-source Dijkstra from all to_zones on reversed graph
    #     dist[i, j] = distance from to_zones[i] to node j (in reversed graph),
    #     which equals distance from node j to to_zones[i] in the forward graph.
    sources = [index[z] for z in to_zones]
    dist, pred = dijkstra(AT, directed=True, indices=sources, return_predecessors=True)

    # Convert to 2D if there's a single source
    if dist.ndim == 1:
        dist = dist[np.newaxis, :]
        pred = pred[np.newaxis, :]

    # --- 4) For each from_zone, pick the best destination and reconstruct path
    def reconstruct_path(u_idx: int, src_row: int) -> List[str]:
        """
        Reconstruct forward path: u -> ... -> m (where m == to_zones[src_row]).
        Uses predecessor row for that specific source.
        """
        path = [u_idx]
        cur = u_idx
        pr = pred[src_row]
        # Walk predecessors until we reach the destination source node
        dest_idx = sources[src_row]
        # If unreachable, pred[cur] == -9999 (SciPy sentinel)
        while cur != dest_idx:
            cur = pr[cur]
            if cur == -9999:
                return []  # unreachable
            path.append(cur)
        return [nodes[i] for i in path]

    results: Dict[str, List[str] | None] = {}
    for fz in from_zones:
        j = index[fz]
        col = dist[
            :, j
        ]  # distances from each destination to this source (in reversed search)
        k = int(np.argmin(col))
        best = col[k]
        if not np.isfinite(best):
            results[fz] = None
            continue
        path = reconstruct_path(j, k)
        if path:
            results[fz] = path
        else:
            results[fz] = None

    return results


def load_inputs(m, switch_data, inputs_dir):
    """
    The RPS target goals input file is mandatory, to discourage people from
    loading the module if it is not going to be used. It is not necessary to
    specify targets for all periods.

    Mandatory input files:
        rps_generators.csv
            RPS_PROGRAM, RPS_GEN, send_bundled_recs*, send_unbundled_recs*

        rps_requirements.csv:
           RPS_PROGRAM, LOAD_ZONE, PERIOD, rps_share, unbundled_rec_limit_fraction*

    Optional input files:
        gen_info.csv
            gen_is_vpp*
    """

    switch_data.load_aug(
        filename=os.path.join(inputs_dir, "rps_generators.csv"),
        optional=True,  # also enables empty files
        index=m.RPS_PROGRAM_GENS,
        param=(m.send_bundled_recs, m.send_unbundled_recs),
    )

    switch_data.load_aug(
        filename=os.path.join(inputs_dir, "rps_requirements.csv"),
        optional=True,  # also enables empty files
        index=m.RPS_RULES,
        param=(m.rps_share, m.unbundled_rec_limit_fraction),
    )

    # load gen_is_vpp if it was created by this module
    if (
        hasattr(m, "gen_is_vpp")
        and hasattr(m.gen_is_vpp, "added_by")
        and m.gen_is_vpp.added_by == __name__
    ):
        switch_data.load_aug(
            filename=os.path.join(inputs_dir, "gen_info.csv"),
            param=(m.gen_is_vpp,),
        )
