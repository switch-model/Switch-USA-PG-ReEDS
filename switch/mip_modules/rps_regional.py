from __future__ import division

# Copyright (c) 2015-2022 The Switch Authors. All rights reserved.
# Licensed under the Apache License, Version 2, which is in the LICENSE file.

import os
from pyomo.environ import *


from switch_model.utilities import unique_list

"""

This module defines a regional Renewable Portfolio Standard (RPS) policy scheme
for the Switch model. In this scheme, each generator in each zone is categorized as RPS-
elegible or not.
Dispatched electricity that is generated by RPS-elegible sources in each
period and zone is summed up and must meet an energy goal in each zone, set as a required percentage
of all energy that is generated in that period. Distributed generation will be counted toward
the percentage if it is marked as eligible for the program; otherwise it will be used to reduce
load, which will partially reduce the amount of other renewables needed.

Distributed generation and VPP generators (interruptible loads)
(gen_is_distributed or gen_is_vpp) are subtracted from load before the RPS
calculation if not marked as RPS-eligible.

Storage units (m.gen_storage_efficiency != '.') will be excluded from the
renewable production total even if marked eligible, because they are not net
sources of power.

This module does not allow eligibility determination based on fuel used in
multi-fuel generators. See switch_model.hawaii.rps for an example of that.
"""


def define_components(m):
    """
    RPS_PROGRAM is a set of program/regions that have target shares of "clean energy".
    RPS_GEN is a set of generators that are eligible for producing "clean energy"(RPS-eligible).

    load_zone is a subset of model regions where RPS goals are defined.
    rps_share[z in load_zone] is the fraction of total generated energy in
        a period in a zone that has to be provided by RPS-elegible generators.
    """
    # indexing set for the zonal requirements: (program, period, zone) combination
    # (These are all the index columns from rps_requirement.csv.)
    m.RPS_RULES = Set(dimen=3, within=Any * m.PERIODS * m.LOAD_ZONES)

    # share target specified for each (program, period, zone) combination
    m.rps_share = Param(m.RPS_RULES, default=float("inf"), within=Reals)

    if not hasattr(m, "gen_is_vpp"):
        m.gen_is_vpp = Param(m.GENERATION_PROJECTS, within=Binary, default=0)
        m.gen_is_vpp.added_by = __name__

    # names of all the RPS programs and periods when they are in effect;
    # each unique pair of values in the first two columns of
    # RPS_requirement.csv is a (program, period) combo
    m.RPS_PROGRAM_PERIODS = Set(
        dimen=2,
        within=Any * m.PERIODS,
        initialize=lambda m: unique_list((pr, pe) for pr, pe, z in m.RPS_RULES),
    )

    # set of RPS programs
    m.RPS_PROGRAMS = Set(
        initialize=lambda m: unique_list(pr for pr, pe in m.RPS_PROGRAM_PERIODS)
    )

    # set of zones that participate in a particular RPS program in a particular period
    # TODO: build these more efficiently
    m.ZONES_IN_RPS_PROGRAM_PERIOD = Set(
        m.RPS_PROGRAM_PERIODS,
        within=m.LOAD_ZONES,
        initialize=lambda m, pr, pe: unique_list(
            _z for (_pr, _pe, _z) in m.RPS_RULES if (_pr, _pe) == (pr, pe)
        ),
    )
    m.ZONES_IN_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS,
        within=m.LOAD_ZONES,
        initialize=lambda m, pr: unique_list(
            _z for (_pr, _pe, _z) in m.RPS_RULES if _pr == pr
        ),
    )

    # set of all valid program/generator combinations (i.e., gens participating
    # in each program); we omit storage gens even if designated as allowed,
    # because they are not a net source of power (could relax this and add net
    # power instead?). Any eligible gens that are not in a home zone for the
    # RPS program will need to be imported on a bundled or unbundled basis.
    m.RPS_PROGRAM_GENS = Set(within=m.RPS_PROGRAMS * m.GENERATION_PROJECTS)
    m.GENS_IN_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS,
        within=m.GENERATION_PROJECTS,
        initialize=lambda m, pr: unique_list(
            _g
            for (_pr, _g) in m.RPS_PROGRAM_GENS
            if _pr == pr and not _g in getattr(m, "STORAGE_GENS", {})
        ),
    )
    # set of all RPS-eligible gens
    m.RPS_GENS = Set(initialize=lambda m: : unique_list(g for pr, g in m.RPS_PROGRAM_GENS)

    # Flags indicating whether each gen should be able to send bundled or
    # unbundled RECs to each program it participates in; send_unbundled_recs is
    # mainly used to indicate which regions allow REC trading with each other;
    # send_bundled_recs is mainly used to manage model size, since policy-wise
    # bundled RECs are always allowed, at least in the U.S. (under the dormant
    # commerce clause), but tracking flows between zones is computationally
    # intensive, so it generally works best to only send bundled RECs to
    # neighboring states or major trading partners (if multiple neighboring
    # states have RPSs, state A could send bundled RECs to state B, which then
    # sends some of its own bundled RECs to stage C, modeling somewhat wider
    # inter-zone trading). Note that if a gen is able to send bundled RECs to 
    # a particular zone for one program, it can also send it to the same zone 
    # for other programs, even if not permitted here (REC transfer is treated
    # as gen-to-zone, not gen-to-program).
    m.send_bundled_recs = Param(m.RPS_PROGRAM_GENS, within=Binary, default=False)
    m.send_unbundled_recs = Param(m.RPS_PROGRAM_GENS, within=Binary, default=True)

    #############
    # Bundled REC (BREC) flows. These are cases where power is scheduled to flow into
    # an RPS's region from an RPS-eligible generator in a zone outside that
    # region. We pre-identify the lowest-loss routes and assume power will
    # always be scheduled to flow along those. Then we require that a matching
    # amount of power is dispatched along these lines. Note that this means
    # bundled RECs can't be applied to one program in one zone and a different
    # program in another zone.
    # Note: in the code below, "BREC-eligible gens" means gens that are
    # eligible to deliver bundled RECs to other zones for RPS programs there.

    # The next few sets are defined empty then filled by populate_rps_routes()

    # All BREC-eligible gens
    m.BREC_EXPORTING_GENS = Set(dimen=1, within=m.GENERATION_PROJECTS)

    # set of lowest-loss routes to zones with an RPS program from external zones
    # with gens that are eligible to export to that program (this set is just a
    # text identifier for each route)
    m.RPS_ROUTES = Set(dimen=2, within=m.LOAD_ZONES * m.LOAD_ZONES)

    # Indexed set of all zones along route from z1 to z2, including first and last
    m.ZONES_ON_RPS_ROUTE = Set(m.RPS_ROUTES, dimen=1, within=m.LOAD_ZONES)

    m.DEST_ZONES_FOR_BREC_EXPORTING_GEN = Set(
        m.BREC_EXPORTING_GENS, dimen=1, within=m.LOAD_ZONES
    )

    # set of all (BREC-eligible gen, dest zone) pairs that send power along
    # directional TX line (zf, zt) (not used, see below)
    # m.BREC_EXPORTING_GEN_DEST_ZONES_FOR_DTX = Set(
    #     m.DIRECTIONAL_TX, dimen=2, within=m.BREC_EXPORTING_GENS * m.LOAD_ZONES
    # )

    @m.BuildAction
    def populate_rps_routes(m):
        # Identify BREC-export-eligible gens, and the routes they can export on.
        # Use these to populate the BREC_EXPORTING_GENS, RPS_ROUTES, 
        # ZONES_ON_RPS_ROUTE and DEST_ZONES_FOR_BREC_EXPORTING_GEN sets.
        # raise NotImplementedError("Need to write set population code.")
        
        # find all routes that BRECs might want to travel; these are from 
        # each zone with a BREC-eligible gen to the disjoint sets of zones
        # covered by various combinations of programs that include one or 
        # more gens in the original zone.
        zones_for_zone = {z: [] for z in m.LOAD_ZONES}
        for pr, g in m.RPS_PROGRAM_GENS:
            z = m.gen_load_zone[g]
            if z in m.ZONES_IN_RPS_PROGRAAM or not m.send_bundled_recs[pr, g]:
                continue
            




    # set of all zones along an RPS ROUTE
    m.RPS_ROUTE_ZONES = Set(
        dimen=3,
        ordered=True,
        within=m.RPS_ROUTES * m.LOAD_ZONES,
        initialize=lambda m: [
            (r, z) for r in m.RPS_ROUTES for z in m.ZONES_ON_RPS_ROUTE[r]
        ],
    )

    # cumulative efficiency up to every zone on every route, incl. start and end
    def rule(m, zf, zt, z):
        if z == zf:
            return 1
        # reuse efficiency up to previous zone (already calculated)
        prev_z = m.ZONES_ON_RPS_ROUTE[zf, zt].prev(z)
        return (
            m.rps_route_efficiency_to_zone[prev_z]
            * m.trans_efficiency[m.trans_d_line[prev_z, z]]
        )

    m.rps_route_efficiency_to_zone = Param(m.RPS_ROUTE_ZONES, rule=rule)

    # allowed combinations of export-eligible gen, route and timepoint
    m.BREC_EXPORTING_GEN_DEST_ZONE_TPS = Set(
        dimen=3,
        within=m.BREC_EXPORTING_GENS * m.LOAD_ZONES * m.TIMEPOINTS,
        initialize=lambda m: [
            (g, z, tp)
            for g in m.BREC_EXPORTING_GENS
            for z in m.DEST_ZONES_FOR_BREC_EXPORTING_GEN[g]
            for tp in m.TPS_FOR_GEN[g]
        ],
    )

    # amount of power to export from each export-eligible gen, per route, per timepoint
    m.ExportBRECsToZoneTP = Var(
        m.BREC_EXPORTING_GEN_DEST_ZONE_TPS, within=NonNegativeReals
    )

    # aggregate values per period and dest zone for total REC balance later

    m.BREC_EXPORTING_GEN_DEST_ZONES = Set(
        dimen=2,
        within=m.BREC_EXPORTING_GENS * m.LOAD_ZONES,
        initialize=lambda m: [
            (g, z)
            for g in m.BREC_EXPORTING_GENS
            for z in m.DEST_ZONES_FOR_BREC_EXPORTING_GEN[g]
        ],
    )

    m.ExportBRECsToZone = Expression(
        m.BREC_EXPORTING_GEN_DEST_ZONES,
        m.PERIODS,
        rule=lambda m, g, z, p: sum(
            m.ExportBRECsToZoneTP[g, z, tp] * m.tp_weight[tp] for tp in m.PERIOD_TPS[p]
        ),
    )
    # same as ExportBRECsToZone, but with losses en route
    m.ImportBRECsToZone = Expression(
        m.BREC_EXPORTING_GEN_DEST_ZONES,
        m.PERIODS,
        rule=lambda m, g, z, p: m.ExportBRECsToZone[g, z, p]
        * m.rps_route_efficiency_to_zone[m.gen_load_zone[g], z, z],
    )

    # commented-out code in the next few blocks reflects experiments to create
    # the TX-flow constraint, efficiently, clearly and without creating too many
    # single-use sets

    # transmission corridors that are affected by BREC export
    m.DIRECTIONAL_TX_ON_BREC_ROUTES = Set(within=m.DIRECTIONAL_TX)

    # for every trans line, BREC trade along routes using that line must not
    # exceed transfers along that line
    m.Require_BRECs_Below_Tx_Transfers = Constraint(
        m.DIRECTIONAL_TX_ON_BREC_ROUTES, m.TIMEPOINTS
    )
    # m.Require_BRECs_Below_Tx_Transfers = Constraint(Any, Any, m.TIMEPOINTS)

    @BuildAction
    def populate_BREC_(m):
        # identify all the gen-dest_zone combos that are active during each
        # period and send BRECs along each line
        routes = {[] for zf, zt in m.DIRECTIONAL_TX for p in m.PERIODS}
        for g in m.BREC_EXPORTING_GENS:
            for dz in m.DEST_ZONES_FOR_BREC_EXPORTING_GEN[g]:
                # assign this g, z pair to all the transmission lines along the way
                zones = iter(m.ZONES_ON_RPS_ROUTE[m.gen_load_zone[g], dz])
                prev_z = next(zones)  # first zone
                for next_z in zones:
                    for p in m.PERIODS_FOR_GEN[g]:
                        routes[prev_z, next_z, p].append((g, z))

        con = m.Require_BRECs_Below_Tx_Transfers
        for (z_from, z_to, p), rts in routes.items():
            if not rts:
                continue

            # add to list of affected Tx corridors
            m.DIRECTIONAL_TX_ON_BREC_ROUTES.add((z_from, z_to))
            # constrain BREC trade
            for tp in m.PERIOD_TPS[p]:
                con[z_from, z_to, tp] = sum(
                    # bundled RECs reaching zone z_from along all g -> zd routes that
                    # use this corridor, net of losses prior to z_from
                    m.ExportBRECsToZoneTP[g, z]
                    * m.rps_route_efficiency_to_zone[m.gen_load_zone[g], zd, z_from]
                    for (g, z) in rts
                ) <= (
                    # power flow along this corridor
                    m.DispatchTx[z_from, z_to, tp]
                )
            # else:
            #     # no BREC trade along this corridor
            #     for tp in m.PERIOD_TPS[p]:
            #         con[z_from, z_to, tp] = Constraint.Skip

    # @m.Constraint(m.DIRECTIONAL_TX, m.TIMEPOINTS)
    # def Require_BRECs_Below_Tx_Transfers(m, zf, zt, tp):
    #     # could save a little time by indexing by period too, but that raises complexity
    #     # ROUTES are (g, dest_zone) pairs that use this directional tx corridor
    #     # TODO: would be neater to get zf, zd, but then we have to find all the
    #     # export-eligible gens for these pairs
    #     ROUTES = m.BREC_EXPORTING_GEN_DEST_ZONES_FOR_DTX[zf, zt]
    #     if not ROUTES:
    #         return Constraint.Skip
    #     bundled_recs_on_dtx = sum(
    #         m.ExportBRECsToZoneTP(g, r, tp) * m.rps_route_efficiency_to_zone[z1, z2, zf]
    #         for (g, r) in ROUTES
    #         if (g, tp) in m.GEN_TPS
    #     )
    #     return bundled_recs_on_dtx <= m.DispatchTx[zf, zt, tp]

    # for every BREC-export-eligible gen, BREC exports must not exceed real-time
    # production
    @m.Constraint(m.BREC_EXPORTING_GENS, m.TIMEPOINTS)
    def Require_Bundled_RECs_Below_Dispatch(m, g, tp):
        return (
            (
                sum(
                    m.ExportBRECsToZoneTP(g, z, tp)
                    for z in m.DEST_ZONES_FOR_BREC_EXPORTING_GEN[g]
                )
                <= m.DispatchGen[g, tp]
            )
            if (g, tp) in m.GEN_TPS
            else Constraint.Skip
        )

    ################
    # Unbundled REC (UREC) trading

    # This is similar to bundled REC (BREC) trading (RECs from specific gens are
    # designated as being exported to a particular zone where they are eligible
    # to participate in one or more RPS programs). However, we only tabulate
    # once per period instead of per timepoint, and we don't worry about the
    # routes the power would flow on. Note that this disallows the same REC from
    # being used for different programs in different zones; we assume each REC
    # moves to one specific zone.

    # balance unbundled trades for every project every period: assign MWh from
    # that project to every allowed export jurisdiction, s.t., constraint that
    # allocations to all jurisdictions must be less than or equal to total
    # production minus bundled assignments

    """
    to define:
    # valid tuples of (REC-export-eligible gen, destination zone, study period)
    # note that we only include a minimal collection of zones that span the programs it is 
    # eligible for
    m.UREC_EXPORTING_GEN_DEST_ZONE_PERIODS
    m.DEST_ZONES_FOR_UREC_EXPORTING_GEN[g]
    """

    # amount of URECs to export from each UREC-export-eligible gen,
    # per destination zone, per timepoint
    m.ExportURECsToZone = Var(
        m.UREC_EXPORTING_GEN_DEST_ZONE_PERIODS, within=NonNegativeReals
    )

    # local REC production from each gen during each period is difference
    # between total production and UREC + BREC production
    @m.Expression(m.RPS_GEN_PERIODS)
    def LocalRECs(m, g, pe):
        TotalBREC = sum(
            m.ExportBRECsToZone[g, z, p] for z in m.DEST_ZONES_FOR_BREC_EXPORTING_GEN[g]
        )
        TotalUREC = sum(
            m.ExportURECsToZone[g, z, p] for z in m.DEST_ZONES_FOR_UREC_EXPORTING_GEN[g]
        )
        TotalDispatch = sum(
            m.DispatchGen[g, tp] * m.tp_weight[tp] for tp in m.PERIOD_TPS[p]
        )
        return TotalDispatch - TotalBREC - TotalUREC

    # make sure local REC production is non-negative for each gen each period,
    # i.e., UREC + BREC production does not exceed total power production
    m.Require_Total_RECs_Below_Dispatch = Constraint(
        m.RPS_GEN_PERIODS, rule=lambda m, g, pe: m.LocalRECs[g, pe] >= 0
    )

    ##############
    # Overall RPS rules and balancing

    # identify
    # - gens local to each rps program
    # - gen, dest_zone pairs for gens that can send URECs to each program
    m.LOCAL_GENS_IN_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS, dimen=1, within=m.GENERATION_PROJECTS
    )
    m.BREC_GEN_DEST_ZONES_IN_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS, dimen=2, within=m.BREC_EXPORTING_GENS * m.LOAD_ZONES
    )
    m.UREC_GEN_DEST_ZONES_IN_RPS_PROGRAM = Set(
        m.RPS_PROGRAMS, dimen=2, within=m.UREC_EXPORTING_GENS * m.LOAD_ZONES
    )

    @m.BuildAction
    def populate_RPS_PROGRAM_GENS(m):
        for pr in m.RPS_PROGRAMS:
            ZONES = m.ZONES_IN_RPS_PROGRAM[pr]
            for g in m.GENS_IN_RPS_PROGRAM:
                if m.gen_load_zone[g] in ZONES:
                    m.LOCAL_GENS_IN_RPS_PROGRAM.add(g)
                else:
                    # external generator; find all the trade routes (usually 1)
                    # that lead back to this program's jurisdiction
                    if g in m.BREC_EXPORTING_GENS:
                        for z in m.DEST_ZONES_FOR_BREC_EXPORTING_GEN[g]:
                            if z in ZONES:
                                m.BREC_GEN_DEST_ZONES_IN_RPS_PROGRAM.add(g, z)
                    if g in m.UREC_EXPORTING_GENS:
                        for z in m.DEST_ZONES_FOR_UREC_EXPORTING_GEN[g]:
                            if z in ZONES:
                                m.UREC_GEN_DEST_ZONES_IN_RPS_PROGRAM.add(g, z)

    # set of all distributed generators and VPP gens that are active in zone z
    # in period p but not identified as RPS-eligible; these are instead
    # subtracted from load when calculating the RPS target
    m.NON_RPS_DIST_DG_VPP_IN_PROGRAM_PERIOD = Set(
        m.RPS_PROGRAM_PERIODS, dimen=1, within=m.GENERATION_PROJECTS
    )

    # populate the set efficiently
    # (from https://pyomo.readthedocs.io/en/6.7.3/pyomo_modeling_components/Sets.html)
    @m.BuildAction()
    def populate_NON_RPS_DIST_DG_VPP_IN_PROGRAM_PERIOD(m):
        for pr, pe in m.RPS_PROGRAM_PERIODS:
            for z in m.ZONES_IN_RPS_PROGRAM_PERIOD[pr, pe]:
                for g in m.GENS_IN_ZONE[z]:
                    if (
                        (m.gen_is_distributed[g] or m.gen_is_vpp[g])
                        and (pr, g) not in m.RPS_PROGRAM_GENS
                        and (g, pe) in m.GEN_PERIODS
                    ):
                        m.NON_RPS_DIST_DG_VPP_IN_PROGRAM_PERIOD[pr, pe].add(g)

    def rule(m, pr, pe):
        # zonal demand for this program/period
        zonal_demand_share = sum(
            m.rps_share[pr, pe, z] * m.zone_total_demand_in_period_mwh[z, pe]
            for z in m.ZONES_IN_RPS_PROGRAM_PERIOD[pr, pe]
        )

        # Any production from dist gen or vpp not included in RPS will instead
        # reduce sales of power below the gross level reported in
        # zone_total_demand_in_period_mwh. That then reduces the amount that
        # needs to be met under the RPS.
        non_rps_dg_vpp_adjustment = sum(
            m.rps_share[pr, pe, m.gen_load_zone[g]] * m.DispatchGen[g] * m.tp_weight[t]
            for g in m.NON_RPS_DIST_DG_VPP_IN_PROGRAM_PERIOD[pr, pe]
            for t in m.TPS_IN_PERIOD[pe]
        )
        return zonal_demand_share - non_rps_dg_vpp_adjustment

    m.RPSTargetMWh = Expression(m.RPS_PROGRAM_PERIODS, rule=rule)

    # fraction of required RECs in each program/period that can come from
    # unbundled trade
    m.unbundled_rec_limit_fraction = Param(
        m.RPS_PROGRAM_PERIODS, within=PercentFraction, default=1
    )

    # Enforce limit on URECs in each RPS program
    def rule(m, pr, pe):
        urec_imports = sum(
            m.ExportURECsToZone[g, z, pe]
            for (g, z) in m.UREC_GEN_DEST_ZONES_IN_RPS_PROGRAM[pr]
            if (g, pe) in m.GEN_PERIODS
        )
        cap = m.unbundled_rec_limit_fraction[pr, pe] * m.RPSTargetMWh[pr, pe]
        return urec_imports <= cap

    m.Require_URECs_Below_Program_Limit = Constraint(
        m.RPS_PROGRAMS, m.PERIODS, rule=rule
    )

    # enforce overall RPS balance, including URECs and BRECs
    def rule(m, pr, pe):
        # calculate production of each category of recs
        local_recs = sum(
            m.LocalRECs[g, pe]
            for g in m.LOCAL_GENS_IN_RPS_PROGRAM[pr]
            if (g, pe) in m.GEN_PERIODS
        )
        brecs = sum(
            m.ImportBRECsToZone[g, z, pe]  # ImportBRECs excludes losses
            for (g, z) in m.BREC_GEN_DEST_ZONES_IN_RPS_PROGRAM[pr]
            if (g, pe) in m.GEN_PERIODS
        )
        urecs = sum(
            m.ExportURECsToZone[g, z, pe]
            for (g, z) in m.UREC_GEN_DEST_ZONES_IN_RPS_PROGRAM[pr]
            if (g, pe) in m.GEN_PERIODS
        )

        # use a scale factor to convert period-long multi-zone total energy
        # into average energy per zone per hour (matching the scale of the MW
        # values used on the RHS for zonal energy balances)
        # (currently unused because it makes shadow value of RPS have weird units)
        # scale = 1.0 / (
        #     m.period_length_hours[pe] * len(m.ZONES_IN_RPS_PROGRAM_PERIOD[pr, pe])
        # )
        # return scale * (local_recs + brecs + urecs) >= scale * m.RPSTargetMWh[pr, pe]

        # define and return the constraint
        return local_recs + brecs + urecs >= m.RPSTargetMWh[pr, pe]

    m.Enforce_RPS_Share = Constraint(m.RPS_PROGRAM_PERIODS, rule=rule)


def load_inputs(m, switch_data, inputs_dir):
    """
    The RPS target goals input file is mandatory, to discourage people from
    loading the module if it is not going to be used. It is not necessary to
    specify targets for all periods.

    Mandatory input files:
        rps_generators.csv
            RPS_PROGRAM, RPS_GEN, send_bundled_recs*, send_unbundled_recs*

        rps_requirements.csv:
           RPS_PROGRAM, PERIOD, rps_share, unbundled_rec_limit_fraction*

    Optional input files:
        gen_info.csv
            gen_is_vpp*

        rps_trade_partners.csv*
            RPS_PROGRAM_FROM, RPS_PROGRAM_TO
    """

    switch_data.load_aug(
        filename=os.path.join(inputs_dir, "rps_generators.csv"),
        optional=True,  # also enables empty files
        set=m.RPS_PROGRAM_GENS,
    )

    switch_data.load_aug(
        filename=os.path.join(inputs_dir, "rps_requirements.csv"),
        optional=True,  # also enables empty files
        index=m.RPS_RULES,
        param=(m.rps_share, m.unbundled_rec_limit_fraction),
    )

    switch_data.load_aug(
        filename=os.path.join(inputs_dir, "rps_trade_partners.csv"),
        optional=True,  # also enables empty files
        set=m.RPS_TRADE_PARTNERS,
    )

    if (
        hasattr(m, "gen_is_vpp")
        and hasattr(m.gen_is_vpp, "added_by")
        and m.gen_is_vpp.added_by == __name__
    ):
        switch_data.load_aug(
            filename=os.path.join(inputs_dir, "gen_info.csv"),
            param=(m.gen_is_vpp,),
        )
